
package org.papamitra.android.dbhelper

import android.content.{ ContentValues, Context }
import android.database.{ Cursor, SQLException }
import android.database.sqlite.{ SQLiteDatabase, SQLiteOpenHelper, SQLiteQueryBuilder }

import scala.collection.mutable.ListBuffer

trait MapperDBHelper[A <: Mapper[A]] { self: MetaMapper[A] =>

  def dbHelper: SQLiteOpenHelper

  private object EmptyCursorIter extends Iterator[Cursor] {
    def hasNext = false
    def next: Cursor = throw new java.util.NoSuchElementException()
  }

  private class CursorIter(cur: Cursor) extends Iterator[Cursor] {
    def hasNext = !cur.isLast()
    def next: Cursor =
      if (cur.moveToNext) cur
      else
        throw new java.util.NoSuchElementException()
  }

  implicit def cursor2Iterable(cur: Cursor): Iterator[Cursor] =
    if (!cur.moveToFirst) EmptyCursorIter
    else {
      cur.moveToPrevious
      new CursorIter(cur)
    }

  def using[A <: { def close(): Unit }, B](param: A)(f: A => B): B =
    try {
      f(param)
    } finally {
      param.close()
    }

  def createTableSQL = "CREATE TABLE " + dbTableName + " (" +
    mappedFieldList.map {
      case FieldHolder(name, _, field) =>
        name + " " + field.dbColumnTypeStr +
          (if (primaryKeyField == field) " PRIMARY KEY AUTOINCREMENT" else "")
    }.mkString(",") +
    ");"

  def dropTableSQL = "DROP TABLE IF EXISTS " + dbTableName + ";"

  def update(mapper: A) {
    val values = new ContentValues()
    mappedFieldList.foreach {
      case FieldHolder(name, meth, _) =>
        val field = meth.invoke(mapper).asInstanceOf[MappedField[AnyRef, A]]
        valput(values, name, field)
    }

    dbHelper.getWritableDatabase.update(dbTableName, values,
      self.primaryKeyField.name + " = " + mapper.primaryKeyField.is,
      null)
  }

  def insert(mapper: A, db:SQLiteDatabase = dbHelper.getWritableDatabase) {
    val values = new ContentValues()
    mappedFieldList.foreach {
      case FieldHolder(name, meth, _) =>
        val field = meth.invoke(mapper).asInstanceOf[MappedField[AnyRef, A]]
        if (!field.isAutoGenerated) valput(values, name, field)
    }

    db.insert(dbTableName, "", values)

  }

  def findAllCursor(where: Option[Where] = None): Cursor = {
    val qb = new SQLiteQueryBuilder()
    qb setTables dbTableName
    where foreach (w => qb.appendWhere(w.toSQL))
    qb.query(dbHelper.getReadableDatabase, null, null, null, null, null, null)
  }

  def findAll(where: Option[Where]): Seq[A] =
    using(findAllCursor(where)) { _.map(cursorToMapper).toList }

  def cursorToMapper(c: Cursor) = {
    val mapper = self.create
    mappedFieldList.foreach {
      case FieldHolder(name, meth, mf) =>
        val field = meth.invoke(mapper).asInstanceOf[MappedField[_, A]]
//        field(dbValue(c, name))
      valget(c,name, field)
    }
    mapper
  }

  def findAll: Seq[A] = findAll(None)
  def findAll(where: Where): Seq[A] = findAll(Some(where))
  def findAllCursor(where: Where): Cursor = findAllCursor(Some(where))

  def valput(v: ContentValues, name: String, field: MappedField[_, A]) =
    field.is match {
      case i: Int => v.put(name, i.asInstanceOf[java.lang.Integer])
      case str: String => v.put(name, str.asInstanceOf[java.lang.String])
      case l: Long => v.put(name, l.asInstanceOf[java.lang.Long])
      case d: Double => v.put(name, d.asInstanceOf[java.lang.Double])
      case b: Boolean => v.put(name, (if (b) 1 else 0).asInstanceOf[java.lang.Integer])
      case _ => throw new Exception("wrong valput")
    }

  def valget(cur: Cursor, colName: String, field: MappedField[_, A]) {
    val colIndex = cur.getColumnIndexOrThrow(colName)
    field.is match {
      case _: Int => fieldset[Int](field, cur.getInt(colIndex))
      case _:String => fieldset[String](field, cur.getString(colIndex))
      case _:Long => fieldset[Long](field, cur.getLong(colIndex))
      case _:Double => fieldset[Double](field, cur.getDouble(colIndex))
      case _:Boolean => fieldset[Boolean](field, (cur.getInt(colIndex) == 1))
    }
  }

  def fieldset[T](field: MappedField[_, A], v: T) {
    val f = field.asInstanceOf[MappedField[T, A]]
    f(v)
  }

}
